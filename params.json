{"name":"PyEndicia","body":"## This project came about from a project that just never got finished\r\nThis API access meets the requirements for using Endicia's API baed on their documentation and my conversations with their dev team and sales team.\r\n\r\n## Fulfillment's\r\n* Change Password\r\n* Buy Postage\r\n* Label\r\n\r\nThese API calls have been implemented as best as I could by only having access to Endicia's test API which is not a full implementation of their true API.\r\n\r\n## Dependencies\r\n* [lxml](https://github.com/lxml/lxml)\r\n* [httplib2](http://code.google.com/p/httplib2/)\r\n* [schema](https://github.com/halst/schema)\r\n* [inject](https://github.com/ivan-korobkov/python-inject)\r\n\r\nThe unittests are written using [nose](https://github.com/nose-devs/nose) so that is also required.\r\n\r\n## Helping out\r\nIf there are any issues with the code please open a issue on github.\r\nIf you have an improvement then open a pull request and make sure to include tests for the code if they are needed.\r\n\r\n## Adding the other API calls.\r\n\r\nYou need to create three new classes in order to add new functionality to the library.\r\n\r\nFirst you need to create a new `XmlBreaker`\r\n\r\n```python\r\nclass EndiciaXmlBreaker:\r\n    def __init__( self ):\r\n        pass\r\n    def setXmlString( self, xml ):\r\n        self.xml = xml\r\n    def to_map( self ):\r\n        pass\r\n```\r\nTo create a new breaker you must only implement the `to_map` method.\r\n\r\nNext you need to create a new `XmlBuilder`\r\n\r\n```python\r\nclass EndiciaXmlBuilder:\r\n    def __init__( self ):\r\n        pass\r\n    def to_string( self ):\r\n        pass\r\n    def to_hash( self ):\r\n        pass\r\n    def to_json( self ):\r\n        pass\r\n    def to_xml( self ):\r\n       pass\r\n```\r\nThe library only uses the `to_xml` so you only need to implement that method the others are for other reasons that were required at the time of my project.\r\n\r\nThe final piece is the `Request` class.\r\n```python\r\nfrom endicia.breakers.BuyPostageXmlBreaker import BuyPostageXmlBreaker\r\nfrom EndiciaRequest import EndiciaRequest\r\n\r\nclass RecreditRequest( EndiciaRequest ):\r\n    def __init__( self ):\r\n        EndiciaRequest.__init__( self )\t\r\n        self.breaker = BuyPostageXmlBreaker()\r\n        self.endiciaCommand = \"/BuyPostageXML\"\r\n        self.endiciaPostName = \"recreditRequestXML\"\r\n```\r\nTo create a new request use the above as a template and fill in the `breaker` with the proper class that you created before. Change the `endiciaCommand` to match the URL of the command. And, finally set `endiciaPostName` to the post variable of the command. This is all that is needed to create a new request.\r\n\r\nAfter you have done the above you can then use your new request object, or one of the other requests already provided as such.\r\n```python\r\nlabel = LabelXmlBuilder()\r\nlabel.setByMap( labelMap )\r\nlabelReq = LabelRequest()\r\ntheLabel = labelReq.get( label )\r\ndumpToFile( theLabel[\"Base64LabelImage\"] )\r\n```\r\nThat's all that is required to get a label from Endicia's API. You need to set your information using an `inject` config module which can be seen below.\r\n```python\r\nimport inject\r\nclass ModuleConfig( object ):\r\n    def __call__( self, injector ):\r\n        injector.bind( \"endiciaPartnerId\", to=\"123456\" )\r\n        injector.bind( \"endiciaAccountId\", to=\"123456\" )\r\n        injector.bind( \"endiciaPassPhrase\", to=\"x\" )\r\n        injector.bind( \"endiciaBaseUrl\", to=\"https://envmgr.com/LabelService/EwsLabelService.asmx\" )\r\n```\r\nUsing the module config like so:\r\n```python\r\nimport inject \r\ninjector = inject.Injector()\r\ninject.register( injector )\r\nconfig( injector )\r\nlabel = LabelXmlBuilder()\r\nlabel.setByMap( labelMap )\r\nlabelReq = LabelRequest()\r\ntheLabel = labelReq.get( label )\r\ndumpToFile( theLabel[\"Base64LabelImage\"] )\r\n```\r\nAnd you have created your label using a centralized configuration.","google":"UA-35032213-1","note":"Don't delete this file! It's used internally to help with page regeneration.","tagline":"Endicia Postage API"}